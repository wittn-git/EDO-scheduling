#pragma once

#include <vector>
#include <functional>
#include <random>
#include <assert.h>


// Class Outline ----------------------------------------------------------------------------------------------------------------------------

using T = std::vector<std::vector<int>>; // Type of genes
using L = double; // Type of fitness values

class Population{

private:

    std::vector<T> genes;
    std::mt19937 generator;

    // Function taking a vector of genes of type T and returning its fitness value vector of type L
    std::function<std::vector<L>(const std::vector<T>&)>& evaluate;
    // Function taking a vector of genes of type T and returning a vector of parents of type T
    std::function<std::vector<T>(const std::vector<T>&, const std::vector<L>&, std::mt19937&)>& selectParents;
    // Function taking a vector of genes of type T and returning a vector of mutated genes of type T
    std::function<std::vector<T>(const std::vector<T>&, std::mt19937&)>& mutate;
    // Function taking a vector of genes of type T and returning a vector of recombined genes of type T
    std::function<std::vector<T>(const std::vector<T>&, std::mt19937&)>& recombine;
    // Function taking two vectors of genes of type T (parents and children) and returning a selected vector of genes of type T
    std::function<std::vector<T>(const std::vector<T>&, const std::vector<L>&, const std::vector<T>&, std::mt19937&)>& selectSurvivors;

public:

    // Constructor for population of size size will with genes generated by function initialize
    Population(
        int seed,
        std::function<std::vector<T>(std::mt19937&)>& initialize,
        std::function<std::vector<L>(const std::vector<T>&)>& evaluate,
        std::function<std::vector<T>(const std::vector<T>&, const std::vector<L>&, std::mt19937&)>& selectParents,
        std::function<std::vector<T>(const std::vector<T>&, std::mt19937&)>& mutate,
        std::function<std::vector<T>(const std::vector<T>&, std::mt19937&)>& recombine,
        std::function<std::vector<T>(const std::vector<T>&, const std::vector<L>&, const std::vector<T>&, std::mt19937&)>& selectSurvivors
    );

    void execute(); //executes one iteration of the evolutionary algorithm
    void execute_multiple(int generations); //executes 'generations' iterations of the evolutionary algorithm
    std::vector<T> get_bests(bool keep_duplicats); //returns the best genes in the population
    std::vector<T> get_genes(); //returns the current genes in the population
    std::string to_string(); //returns a string representation of the population
    std::string bests_to_string(bool reciproc); //returns a string representation of the best genes in the population, reciproc = true will return the reciproc of the fitness values
    
    void set_evaluate(const std::function<std::vector<L>(const std::vector<T>&)>& evaluate);
    void set_selectParents(const std::function<std::vector<T>(const std::vector<T>&, const std::vector<L>&, std::mt19937&)>& selectParents);
    void set_mutate(const std::function<std::vector<T>(const std::vector<T>&, std::mt19937&)>& mutate);
    void set_recombine(const std::function<std::vector<T>(const std::vector<T>&, std::mt19937&)>& recombine);
    void set_selectSurvivors(const std::function<std::vector<T>(const std::vector<T>&, const std::vector<L>&, const std::vector<T>&, std::mt19937&)>& selectSurvivors);
    
};