#pragma once

#include <vector>
#include <functional>
#include <random>
#include <assert.h>
#include <map>
#include <tuple>

template <typename T>
struct Diversity_Preserver {
    int index;
    bool first;
    std::map<std::pair<int, int>, double> diversity_scores;
    std::vector<T> genes;
};

// Class Outline ----------------------------------------------------------------------------------------------------------------------------

template <typename T, typename L> // T: type of genes, L: type of fitness values
class Population{

protected:

    std::vector<T> genes;
    std::mt19937 generator;
    int generation;

    // Function taking a vector of genes of type T and returning its fitness value vector of type L
    std::function<std::vector<L>(const std::vector<T>&)>& evaluate;
    // Function taking a vector of genes of type T and returning a vector of parents of type T
    std::function<std::vector<T>(const std::vector<T>&, const std::vector<L>&, std::mt19937&)>& selectParents;
    // Function taking a vector of genes of type T and returning a vector of mutated genes of type T
    std::function<std::vector<T>(const std::vector<T>&, std::mt19937&)>& mutate;
    // Function taking a vector of genes of type T, a child T and a diversity preserver and a diversity preserver
    std::function<Diversity_Preserver<T>(const std::vector<T>&, const T&, const Diversity_Preserver<T>&, std::mt19937&)>& selectSurvivors;
    
    //struct saving the diversity scores of the genes
    Diversity_Preserver<T> div_preserver;

public:

    // Constructor for population of size size will with genes generated by function initialize
    Population(
        int seed,
        std::function<std::vector<T>(std::mt19937&)>& initialize,
        std::function<std::vector<L>(const std::vector<T>&)>& evaluate,
        std::function<std::vector<T>(const std::vector<T>&, const std::vector<L>&, std::mt19937&)>& selectParents,
        std::function<std::vector<T>(const std::vector<T>&, std::mt19937&)>& mutate,
        std::function<Diversity_Preserver<T>(const std::vector<T>&, const T&, const Diversity_Preserver<T>&, std::mt19937&)>& selectSurvivors
    );

    // Default constructor for initialization purposes
    Population();

    //executes one iteration of the evolutionary algorithm
    virtual void execute();   
    //executes iterations of the evolutionary algorithm until the termination criterion is met                                              
    virtual void execute(std::function<bool(Population<T,L>&)> termination_criterion);   
    //get maximum fitness value over the course of the algorithm
    L get_best_fitness(std::function<std::vector<L>(const std::vector<T>&)>& evaluate);                 
    //returns the best genes in the population, using the given evaluate function
    std::vector<T> get_bests(bool keep_duplicats, std::function<std::vector<L>(const std::vector<T>&)>& evaluate);       
    //returns the current genes in the population           
    std::vector<T> get_genes(bool keep_duplicats);   
    //returns the number of generation that have been executed               
    int get_generation();
    //returns the size of the population
    int get_size(bool keep_duplicates);        
    //sets the genes in the population to new_genes                                         
    void set_genes(std::vector<T> new_genes);      
    //returns the current diversity given a diversity measure function on the population level
    double get_diversity(std::function<double(const std::vector<double>&)> diversity_measure_population);

};

// Class Implementation ---------------------------------------------------------------------------------------------------------------------

template <typename T, typename L>
Population<T, L>::Population(
    int seed,
    std::function<std::vector<T>(std::mt19937&)>& initialize,
    std::function<std::vector<L>(const std::vector<T>&)>& evaluate,
    std::function<std::vector<T>(const std::vector<T>&, const std::vector<L>&, std::mt19937&)>& selectParents,
    std::function<std::vector<T>(const std::vector<T>&, std::mt19937&)>& mutate,
    std::function<Diversity_Preserver<T>(const std::vector<T>&, const T&, const Diversity_Preserver<T>&, std::mt19937&)>& selectSurvivors
) : generation(0), generator(seed), evaluate(evaluate), selectParents(selectParents), mutate(mutate), selectSurvivors(selectSurvivors) {
    genes = initialize(generator);
    assert(genes.size() > 0 && "initialize function must return a non-empty vector");
    div_preserver = Diversity_Preserver<T>{0, true, std::map<std::pair<int, int>, double>(), genes};
    div_preserver = selectSurvivors(genes, genes[0], div_preserver, generator);
}

template <typename T, typename L>
void Population<T, L>::execute() {
    generation++;
    std::vector<L> fitnesses = evaluate(genes);
    std::vector<T> parents = selectParents(genes, fitnesses, generator);
    std::vector<T> children = mutate(parents, generator);
    div_preserver = selectSurvivors(genes, children[0], div_preserver, generator);
    genes = div_preserver.genes;
}

template <typename T, typename L>
void Population<T, L>::execute(std::function<bool(Population<T,L>&)> termination_criterion){
    while(!termination_criterion(*this)){
        execute();
    }
}

template <typename T, typename L>
std::vector<T> Population<T, L>::get_bests(bool keep_duplicats, std::function<std::vector<L>(const std::vector<T>&)>& evaluate){
    std::vector<T> bests;
    std::vector<L> fitnesses = evaluate(genes);
    auto min_it = std::min_element(fitnesses.begin(), fitnesses.end());
    for(int i = 0; i < genes.size(); i++){
        if(fitnesses[i] == *min_it){
            bests.emplace_back(genes[i]);
        }
    }
    if(keep_duplicats){
        return bests;
    }
    std::sort(bests.begin(), bests.end());
    bests.erase(std::unique(bests.begin(), bests.end()), bests.end());
    return bests;
}

template <typename T, typename L>
L Population<T, L>::get_best_fitness(std::function<std::vector<L>(const std::vector<T>&)>& evaluate){
    std::vector<L> fitnesses = evaluate(genes);
    auto min_it = std::min_element(fitnesses.begin(), fitnesses.end());
    return *min_it;
}

template <typename T, typename L>
std::vector<T> Population<T, L>::get_genes(bool keep_duplicats){
    if(keep_duplicats) return genes;
    std::vector<T> genes_copy = genes;
    std::sort(genes_copy.begin(), genes_copy.end());
    genes_copy.erase(std::unique(genes_copy.begin(), genes_copy.end()), genes_copy.end());
    return genes_copy;
}

template <typename T, typename L>
int Population<T, L>::get_generation(){
    return generation;
}

template <typename T, typename L>
int Population<T, L>::get_size(bool keep_duplicates){
    return get_genes(keep_duplicates).size();
}

template <typename T, typename L>
void Population<T, L>::set_genes(std::vector<T> new_genes){
    genes = new_genes;
}

template <typename T, typename L>
double Population<T, L>::get_diversity(std::function<double(const std::vector<double>&)> diversity_measure_population){
    std::vector<double> diversity_scores;
    diversity_scores.reserve(div_preserver.diversity_scores.size()); 
    for (const auto& entry : div_preserver.diversity_scores) {
        const auto& indices = entry.first;
        if (indices.first != div_preserver.index && indices.second != div_preserver.index) {
            diversity_scores.push_back(entry.second);
        }
    }
    return diversity_measure_population(diversity_scores);
}